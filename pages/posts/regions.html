title: A region manager for single-paged apps
author: Todd Kennedy
date: 05-12-2012T23:22
description: A simple system for showing and deleting views from a page
keywords: underscore, regions, javascript, jquery, backbone, single-paged app

{% extends "post.html" %}
{% block body %}

{% load markup %}
{% filter markdown %}
In building out the new version of our site, it became apparently early on that I needed some good way to manage adding views to and removing views from the DOM. Backbone doesn't provide a lot of functionality in the perspective out of the box; `Backbone.View` provides both a `remove` and an `undelegateEvents` method, but neither of those gets automatically called when the view object is destroyed (although that has to do more with javascript's object model and the fact that [delete doesn't work like you think it should](http://perfectionkills.com/understanding-delete/)).

The `remove` method just calls the `remove` method of the DOM manipulation library you're using (jQuery in our case), and `undelegateEvents` just deletes the events delegated to the object via the `events` hash provided in the view declaration (and doesn't necessarily need tobe called but in special circumstances).

The problem here though is that if you're adding and removing views from the DOM and you're not cleaning up after yourself correctly you're going to end up with dreaded [zombie attacks](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/) &#151; where due to the nature of how javascript closures work (if there's a reference left open to them they will remain in memory; a reference can be as simple as a bound DOM event), views you think have been destroyed are still in memory (causing memory leaks) AND responding to events as if they were still in the page.

Luckily there are a couple of patterns and libraries that help you with regards to these issues. For a short time while building out the prototype for the site I was using [Backbone.Marionette](http://marionettejs.com/)'s regions system for handling this, but after switching to Dust for templating and having to start using the asynchronous version of it, I realized it was overkill. The only part of Backbone.Marionette I was using was the region manager, and having to include all that code in my page was killing me. (Plus I kept having a bug where the view wasn't defined when I was trying to close it and I didn't <del>feel like spending</del> didn't have the time to troubleshoot it.)

So I whipped up this example inspired by the region manager provided by Backbone.Marionette, but designed from the ground up to be asynchronous &#151; this means not only do you need jQuery, but you also need your `render` method from your view to return an instance of a `$.Deferred` object that is resolved when the view is attached to the DOM element. (If you're wondering what `$.Deferred` is, or how promises work, or really, just about asynchronous programming in Javascript in general, I HIGHLY recommend [Async Javascript](http://www.amazon.com/Async-JavaScript-ebook/dp/B007N81FE2/ref=tmm_kin_title_0?ie=UTF8&amp;qid=1354767420&amp;sr=8-1) by Trevor Burnham.)

<script src="https://gist.github.com/4221647.js"> </script>

## Usage example

    var MyView = Backbone.View.extend({
        render: function(){
            var dfd = $.Deferred();
            this.$el.html('<h1>I am a title!</h1>')
            dfd.resolve();
            return dfd;
        }
    });

    var MyRegion = new Region('div#region');

    MyRegion.show(new MyView);

The key point being that the render function resolves the deferred object it creates when the HTML generated by the view is attached to the DOM. And because it too returns a deferred object, you can use that to manipulate the view after the view has been attached.

You'll notice that we call `MyView.close()` in the `clear` method on the region. This is because we not only bind DOM events to our view methods, but our application uses an event `pipeline` or `dispatch` system to allow independent blocks of code (closures) communicate with each other. Since we're doing some extra binding in the `initialize` method, we have to take great care to unbind those listeners on the dispatch queue, or we'll still end up with zombie event listeners performing actions from beyond the grave. But I'll leve that pattern alone for a follow up post.

{% endfilter %}
{% endblock %}